COP4620: Construction of Language Translators
Project 3
Stephen Shappley N01184718
Dr. Roger Eggen
28 March 2019

Running the program:
1. Execute `make` to compile the program
2. Execute `p3` script to execute the program

Input:
The application accepts a file name as argument 0 to be processed.

Output:
All output is printed to the console.

Overall Design:
The objective of this Semantic Analyzer is to follow the structure of a parse
    tree as closely as possible.
That is, each Node contains 0..n children Nodes, each corresponding to a
    particular production rule.
For example, in the grammar you have:

        program -> declaration-list
        declaration-list -> declaration declaration-list-prime

So each 'program' instance has a 'declaration-list' who in turn has a
    'declaration' and 'declaration-list-prime', and so on.
This approach allows a tree-like structure to be created.

The semantic validity of the tree is evaluated using a simple principle:
    a Node is valid when all of its children are valid.
That is, 'program' is valid when 'declaration-list' is valid.
'declaration-list' is valid when 'declaration' is valid and
    'declaration-list-prime' is valid, and so on.

Each Node type is responsible for evaluating itself for semantic validity then
    calling its children's validity functions.
For example, a function declaration is responsible for checking for
    duplicate function names, adding itself to the symbol table, and then
    checking the validity of its children (params, compound-stmt).
Each of these is then responsible for checking themselves and their children,
    and so on.

This approach allowed for significantly cleaner and more maintainable code than
    most other people's projects where they had 1 file with 3000 lines of a
    giant switch-case.